<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>cover/Elixir.Domain.User.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/maciej/Documents/dev/elixir/showcase01/apps/domain/lib/domain/user.ex by COVER 2016-09-16 at 21:53:46

****************************************************************************

        |  defmodule Domain.User do
        |    @moduledoc false
        |  
        |    use Ecto.Schema
        |    import Ecto.Changeset
        |  
<font color=red>     0..|    schema "user" do</font>
        |      field :first_name, :string, null: false
        |      field :last_name, :string, null: false
        |      field :email, :string, null: false
        |      field :password_hash, :string, null: false
        |      field :password, :string, virtual: true
        |  
        |      timestamps()
        |    end
        |  
        |    def create_changeset(user, params \\ %{}) do
        |      user
        |      |&gt; cast(params, [:first_name, :last_name, :email, :password])
        |      |&gt; validate_required([:first_name, :last_name, :email, :password])
        |      |&gt; validate_length(:password, min: 8)
        |      |&gt; validate_confirmation(:password, message: "Passwords do not match")
        |      |&gt; validate_format(:email, ~r/@/)
        |      |&gt; hash_password
        |      |&gt; unique_constraint(:email)
        |    end
        |  
        |    def update_changeset(user, params \\ %{}) do
        |      user
        |      |&gt; cast(params, [:first_name, :last_name, :email, :password])
        |      |&gt; validate_required([:first_name, :last_name, :email, :password])
        |      |&gt; validate_length(:password, min: 8)
        |      |&gt; validate_confirmation(:password, message: "Passwords do not match")
        |      |&gt; validate_format(:email, ~r/@/)
        |      |&gt; hash_password
        |      |&gt; unique_constraint(:email)
        |    end
        |  
        |    defp hash_password(changeset) do
        |      password = get_change(changeset, :password)
        |  
        |      case password do
        |        x when is_bitstring(x) -&gt;
        |          changeset
        |          |&gt; put_change(:password_hash, Comeonin.Bcrypt.hashpwsalt(password))
        |          |&gt; put_change(:password, nil)
        |        _                      -&gt;
        |          changeset
        |      end
        |    end
        |  end
</pre>
</body>
</html>
